# Processor
## Aidan Frutos (af314)

### Processor Background
I used the 5 stage pipeline with stages fetch, decode, execute, memory, and writeback. Each stage has dffs that hold the values of the instructions, data values, and controls at the end of each stage. 

In the fetch stage, I handle my pc incrementing, stalling, and jumping. I use my alu to handle any additions needed to find the next pc needed. I also handle the bypassing needed for jr and branches. I did run into issues trying to implement the jal bypassing, so I resorted to using stalls for cases where a register still needs to be updated. Next, I handle the stalls required for certain hazards like RAW using lw or jal then sw on r31. When this happens I stall the pc and add a nop to ensure the correct values are being read. I also implemented a flushcontrol that will flush instructions that come after the jump or branch if they are taken. This removes the incorrect instructions and they are replaced with nops. 

In the decode stage, I read the values from the dffs in the fetch stage. This stage is where I decide whether a branch or jump is taken. I implemented fast branches because it will reduce the branch taken penalty by 1. This however does complicate the bypassing because I need to bypass into decode now as well. In this stage, I also create controls that determine whether the instruction is a load, store, multdiv, as well as keeping the jal address.

In the execute stage, I read the decode out instruction and determine which operation to perform. Before I get started with the operations, I check if bypassing is needed by checking the memory and wb stages to see fi there are overlapping registers and the instruction in memory and wb is a writing instruction (if it writes then it updates the value in that register). If there are I read the values directly from those stages instead. I prioritze the memory stage over the wb stage because this is the one that holds the most recent value. I also made sure to add in a check to see if the instruction is a jal because that would write to r31. This way I retrieve the values as needed in the current instruction. I had to make sure I handled the different types of instructions correctly (I-type, R-type, etc.) because they each have different formatted instruction codes and number of registers used in instruction. Once, I’ve selected the correct data values (whether its I-type and needs an immediate or r-type and needs two register values), I then run my alu and muldiv modules on the two data operands. For the multdiv operation, I make sure to stall the pipeline until the md_ready signal is sent. The multdiv module also only runs when the ctrl signals for mult or div are sent so this stall only occurs when the instruction is a multiplication or division. After, I’ve done these operations, I choose the result based off the operation and raise any exception in r30 as needed. These values are stored in dffs at the end of the execute stage to pass through to the next stage.

In the memory stage, I read from dmem and store data as needed. I then read data from memory and decide whether I use the result from the execute stage or use the memory result (because its a load).
In the writeback stage, I choose which register to write to and what data to send based on whether it is a jal, exception, or a store (in which case ctrl_writeEnable is set to low.

### Problems with Processor
My processor is able to handle all normal operations without hazards, but I have some issues with the hazard handling in regards to bypassing. First, I struggled to get the setx and bex bypassing to work correctly. When I was able to get my setx bypassing to work, it would mess up my other bypassing and cause them to fail instead. This had to do with my bypass selection because it would have to select the r30 data from memory or wb when an exception flag was raised in those stages. Below is how I tried to set ex_operandA to account for setx bypassing. If the exception flag was raised then I used the exception code for that stage. If the instruction was a setx I use the target value (sign extended) from that stage.

My issue with this was that it would somehow mess up my other bypassing as well and I couldn’t figure out why. I attempted to look through the gtkwave files for the relevant tests, but I was not able to understand how the setx was interfering with my other bypasses. For bex I ran into issues with the bypassing because of my issues with getting setx to work correctly. These are the largest things that I couldn’t figure out for my processor.

The second issue was with my jal edge case bypassing. I was having trouble getting the jal to bypass the information to the next operation. I tried to add code to check if there was a jal in the previous instructions and if there was check if r31 was being accessed by any of the next operations, but I think my implementation was incorrect. Below shows how I was selecting the rd for those instructions using a ternary operation. This would cause rd (of mem & wb) to be 31 when it was a jal and otherwise use the rd from the instruction. These rd_effectives were then used to check with the current instruction to see if there was an overlap of registers.

The next issues arise with my jal jr bypassing which was an extension of the previous issue. In the test code my jr kept jumping to the old r31 value (14) instead of the new r31 (8) that was set by the jal. I tried to set a bypass so that when there was a jal into a jr $31 then it would use the newest value of r31, but I couldn’t get my timing to work correctly. I then tried to add a stall so that nops would be entered so that at least it would still function even if it was slower, but this still didn’t fix the issue. I think this is because of how my jumps are calculated in the decode stage. So the jr already sees the value of r31 before the nops are sent through
